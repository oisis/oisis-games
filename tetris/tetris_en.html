<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris - The Old Builder</title>
    <link rel="icon" type="image/svg+xml" href="../images/favicon.svg">
    <style>
        body {
            background-color: #050505;
            color: #b0b0b0;
            font-family: 'Times New Roman', serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-image: url('../images/background_dark.png');
            background-position: center;
            background-size: cover;
            background-attachment: fixed;
        }
        h1 {
            color: #8a0f0f;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0px 0px 10px rgba(138, 15, 15, 0.4);
            margin-bottom: 20px;
        }
        canvas {
            border: 1px solid #333;
            background-color: #080808;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.95);
            display: block;
        }
        #score {
            margin-top: 20px;
            font-size: 1.2em;
            color: #999;
        }
        .controls {
            margin-top: 10px;
            font-size: 0.8em;
            color: #444;
            font-style: italic;
        }
        .container {
            border: 1px solid #333;
            padding: 50px;
            background-color: rgba(8, 8, 8, 0.9);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.95);
            text-align: center;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .container::after {
            content: "";
            position: absolute;
            top: 6px; left: 6px; right: 6px; bottom: 6px;
            border: 1px solid #5e0b0b;
            pointer-events: none;
            opacity: 0.5;
        }
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 0.9rem;
            padding: 5px 10px;
            color: #999;
            text-decoration: none;
            border: 1px solid #333;
            background-color: transparent;
            transition: all 0.3s;
            z-index: 10;
        }
        .back-button:hover {
            color: #ff3333;
            border-color: #8a0f0f;
            box-shadow: 0 0 10px #8a0f0f;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            color: #777;
            text-decoration: underline;
            z-index: 10;
        }
        .theme-switch:hover {
            color: #b0b0b0;
        }
        body.light-mode {
            background-image: url('../images/background_light.png');
        }
        body.light-mode .container {
            background-color: rgba(240, 240, 240, 0.9);
            border-color: #bbb;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.2);
        }
        body.light-mode .container::after {
            border-color: #8a0f0f;
            opacity: 0.3;
        }
        body.light-mode h1 {
            text-shadow: 0px 0px 5px rgba(138, 15, 15, 0.2);
        }
        body.light-mode .back-button {
            color: #555;
            border-color: #bbb;
        }
        body.light-mode .back-button:hover {
            color: #cc0000;
            border-color: #cc0000;
            box-shadow: 0 0 5px rgba(204, 0, 0, 0.3);
        }
        .game-wrapper {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            justify-content: center;
            flex-wrap: wrap;
        }
        .scoreboard {
            border: 1px solid #333;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            min-width: 200px;
            text-align: left;
        }
        .scoreboard h3 {
            color: #8a0f0f;
            margin-top: 0;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
            font-size: 1.1em;
        }
        .scoreboard ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .scoreboard li {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #222;
            font-size: 0.9em;
            color: #999;
        }
        body.light-mode .scoreboard {
            background-color: rgba(255, 255, 255, 0.5);
            border-color: #bbb;
        }
        body.light-mode .scoreboard h3 {
            border-bottom-color: #ccc;
        }
        body.light-mode .scoreboard li {
            border-bottom-color: #ddd;
            color: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="../index_en.html" class="back-button">Back</a>
        <div class="theme-switch" onclick="toggleTheme()">Toggle Theme</div>
        <h1>Tetris</h1>
        <div class="game-wrapper">
            <div class="game-area">
                <canvas id="gameCanvas"></canvas>
                <div id="score">Echoes of Blood: 0</div>
                <div class="controls">Arrows: Move/Rotate</div>
            </div>
            <div class="scoreboard">
                <h3>High Scores</h3>
                <ul id="scoreList"></ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        if (localStorage.getItem('theme') === 'light') {
            document.body.classList.add('light-mode');
        }

        const ROW = 20;
        const COL = 10;
        let SQ = 20;
        let VACANT = "#080808";

        function resizeGame() {
            // Calculate square size to fit approx 60% of screen height
            let availableHeight = window.innerHeight * 0.6;
            SQ = Math.floor(availableHeight / ROW);
            canvas.height = SQ * ROW;
            canvas.width = SQ * COL;
            drawBoard();
        }

        window.addEventListener('resize', resizeGame);

        // Shapes
        const PIECES = [
            [Z, "#a93226"],
            [S, "#1e8449"],
            [T, "#6c3483"],
            [O, "#b7950b"],
            [L, "#af601a"],
            [I, "#117864"],
            [J, "#21618c"]
        ];

        // Piece definitions
        function I() { return [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]]; }
        function J() { return [[1,0,0],[1,1,1],[0,0,0]]; }
        function L() { return [[0,0,1],[1,1,1],[0,0,0]]; }
        function O() { return [[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]; }
        function S() { return [[0,1,1],[1,1,0],[0,0,0]]; }
        function T() { return [[0,1,0],[1,1,1],[0,0,0]]; }
        function Z() { return [[1,1,0],[0,1,1],[0,0,0]]; }

        // Board
        let board = [];
        for(let r = 0; r < ROW; r++){
            board[r] = [];
            for(let c = 0; c < COL; c++){
                board[r][c] = VACANT;
            }
        }

        resizeGame();

        function drawSquare(x, y, color){
            ctx.fillStyle = color;
            ctx.fillRect(x*SQ, y*SQ, SQ, SQ);
            ctx.strokeStyle = "rgba(120, 160, 160, 0.1)";
            ctx.strokeRect(x*SQ, y*SQ, SQ, SQ);
        }

        function drawBoard(){
            const isLight = document.body.classList.contains('light-mode');
            VACANT = isLight ? "#f0f0f0" : "#080808";
            
            for(let r = 0; r < ROW; r++){
                for(let c = 0; c < COL; c++){
                    // If cell is "vacant" (has old background color), refresh it
                    if (board[r][c] === "#080808" || board[r][c] === "#f0f0f0") {
                        board[r][c] = VACANT;
                    }
                    drawSquare(c, r, board[r][c]);
                }
            }
        }

        // Piece
        let p = randomPiece();

        function randomPiece(){
            let r = Math.floor(Math.random() * PIECES.length);
            return new Piece(PIECES[r][0], PIECES[r][1]);
        }

        function Piece(tetromino, color){
            this.tetromino = tetromino();
            this.color = color;
            this.tetrominoN = 0; // start from the first pattern
            this.activeTetromino = this.tetromino;
            this.x = 3;
            this.y = -2;
        }

        Piece.prototype.fill = function(color){
            for(let r = 0; r < this.activeTetromino.length; r++){
                for(let c = 0; c < this.activeTetromino.length; c++){
                    if(this.activeTetromino[r][c]){
                        drawSquare(this.x + c, this.y + r, color);
                    }
                }
            }
        }

        Piece.prototype.draw = function(){
            this.fill(this.color);
        }

        Piece.prototype.unDraw = function(){
            this.fill(VACANT);
        }

        Piece.prototype.moveDown = function(){
            if(!this.collision(0, 1, this.activeTetromino)){
                this.unDraw();
                this.y++;
                this.draw();
            }else{
                this.lock();
                p = randomPiece();
            }
        }

        Piece.prototype.moveRight = function(){
            if(!this.collision(1, 0, this.activeTetromino)){
                this.unDraw();
                this.x++;
                this.draw();
            }
        }

        Piece.prototype.moveLeft = function(){
            if(!this.collision(-1, 0, this.activeTetromino)){
                this.unDraw();
                this.x--;
                this.draw();
            }
        }

        Piece.prototype.rotate = function(){
            let nextPattern = this.tetromino;
            // Transpose + Reverse for rotation
            let N = this.activeTetromino.length;
            let newPattern = [];
            for(let i=0; i<N; i++) { newPattern.push(new Array(N).fill(0)); }
            for(let y=0; y<N; y++) {
                for(let x=0; x<N; x++) {
                    newPattern[x][N-1-y] = this.activeTetromino[y][x];
                }
            }
            
            if(!this.collision(0, 0, newPattern)){
                this.unDraw();
                this.activeTetromino = newPattern;
                this.draw();
            }
        }

        let score = 0;

        Piece.prototype.lock = function(){
            for(let r = 0; r < this.activeTetromino.length; r++){
                for(let c = 0; c < this.activeTetromino.length; c++){
                    if(!this.activeTetromino[r][c]){ continue; }
                    if(this.y + r < 0){
                        // Game Over
                        handleGameOver();
                        break;
                    }
                    board[this.y+r][this.x+c] = this.color;
                }
            }
            // Remove full rows
            for(let r = 0; r < ROW; r++){
                let isRowFull = true;
                for(let c = 0; c < COL; c++){
                    isRowFull = isRowFull && (board[r][c] != VACANT);
                }
                if(isRowFull){
                    for(let y = r; y > 1; y--){
                        for(let c = 0; c < COL; c++){
                            board[y][c] = board[y-1][c];
                        }
                    }
                    for(let c = 0; c < COL; c++){
                        board[0][c] = VACANT;
                    }
                    score += 10;
                    // Speed up every 50 points (5 lines)
                    let level = Math.floor(score / 50);
                    dropInterval = Math.max(100, 1000 - (level * 50));
                    document.getElementById('score').innerText = 'Echoes of Blood: ' + score;
                }
            }
            drawBoard();
        }

        Piece.prototype.collision = function(x, y, piece){
            for(let r = 0; r < piece.length; r++){
                for(let c = 0; c < piece.length; c++){
                    if(!piece[r][c]){ continue; }
                    let newX = this.x + c + x;
                    let newY = this.y + r + y;
                    if(newX < 0 || newX >= COL || newY >= ROW){ return true; }
                    if(newY < 0){ continue; }
                    if(board[newY][newX] != VACANT){ return true; }
                }
            }
            return false;
        }

        document.addEventListener("keydown", CONTROL);

        function CONTROL(event){
            if(event.keyCode == 37){ p.moveLeft(); dropStart = Date.now(); }
            else if(event.keyCode == 38){ p.rotate(); dropStart = Date.now(); }
            else if(event.keyCode == 39){ p.moveRight(); dropStart = Date.now(); }
            else if(event.keyCode == 40){ p.moveDown(); }
        }

        let dropInterval = 1000;
        let dropStart = Date.now();
        function drop(){
            let now = Date.now();
            let delta = now - dropStart;
            if(delta > dropInterval){
                p.moveDown();
                dropStart = Date.now();
            }
            requestAnimationFrame(drop);
        }

        drop();

        function handleGameOver() {
            if (score > 0) {
                let name = prompt("Game Over! Your score: " + score + ". Enter your nickname:", "Player");
                while (name !== null && name.trim().length === 0) {
                    name = prompt("Nickname cannot be empty! Enter your nickname:", "Player");
                }
                if (name) {
                    saveHighScore(score, name.trim());
                    updateScoreboard();
                }
            }
            // Reset board
            for(let r = 0; r < ROW; r++){
                for(let c = 0; c < COL; c++){
                    board[r][c] = VACANT;
                }
            }
            score = 0;
            dropInterval = 1000;
            document.getElementById('score').innerText = 'Echoes of Blood: ' + score;
            drawBoard();
        }

        function saveHighScore(score, name) {
            let scores = JSON.parse(localStorage.getItem('tetrisHighScores')) || [];
            scores.push({ score: score, name: name, date: new Date().toLocaleDateString() });
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 10);
            localStorage.setItem('tetrisHighScores', JSON.stringify(scores));
        }

        function updateScoreboard() {
            const scores = JSON.parse(localStorage.getItem('tetrisHighScores')) || [];
            const list = document.getElementById('scoreList');
            list.innerHTML = scores.map(s => `<li><span>${s.name || s.date}</span> <span>${s.score}</span></li>`).join('');
        }

        updateScoreboard();

        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            const isLight = document.body.classList.contains('light-mode');
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
            drawBoard(); // Redraw to update background colors
            p.draw(); // Redraw current piece
        }
    </script>
</body>
</html>