<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Robblorne</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
        :root { --tile-size: 64px; --blood: #8a0000; --gold: #c5a059; --bg: #050505; }
        body { background-color: var(--bg); color: var(--gold); font-family: 'Cinzel', serif; display: flex; flex-direction: column; align-items: center; margin: 0; padding-top: 20px; overflow: hidden; }
        
        #game-header { 
            width: 832px; 
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center; 
            padding: 10px 20px; 
            border: 1px solid #222; 
            background: linear-gradient(to right, #000, #150000, #000); 
            box-shadow: 0 5px 20px rgba(138, 0, 0, 0.3); 
            margin-bottom: 20px; 
        }

        .restart-btn { justify-self: end; background: transparent; color: var(--gold); border: 1px solid var(--gold); padding: 5px 15px; font-family: 'Cinzel', serif; cursor: pointer; transition: 0.3s; text-transform: uppercase; font-size: 0.8rem; }
        .restart-btn:hover { background: var(--gold); color: black; box-shadow: 0 0 10px var(--gold); }
        .stat { justify-self: start; font-size: 1rem; }
        .stat b { color: #bc0000; text-shadow: 0 0 5px red; }
        
        #game-title { margin: 0; font-size: 1.8rem; letter-spacing: 8px; text-align: center; transition: 0.3s; }
        
        .msg-death { 
            color: #fff !important; 
            text-shadow: -1px -1px 0 #bc0000, 1px -1px 0 #bc0000, -1px 1px 0 #bc0000, 1px 1px 0 #bc0000, 0 0 15px #ff0000;
        }
        
        .msg-win { 
            font-size: 1.3rem !important;
            color: #fff !important; 
            text-shadow: -1px -1px 0 #8a0000, 1px -1px 0 #8a0000, -1px 1px 0 #8a0000, 1px 1px 0 #bc0000, 0 0 10px #ff0000;
        }

        #canvas-container { border: 4px solid #1a1a1a; box-shadow: 0 0 100px rgba(0,0,0,1); position: relative; }
        canvas { display: block; background: #080808; }

        #score-board {
            width: 832px;
            text-align: right;
            margin-top: 10px;
            font-size: 1rem;
            color: #444;
            letter-spacing: 2px;
        }
        #total-points { color: var(--blood); font-weight: bold; }
    </style>
</head>
<body>

    <div id="game-header">
        <div class="stat">KROPLE: <b id="blood-val">0 / 0</b></div>
        <h1 id="game-title">ROBBLORNE</h1>
        <button class="restart-btn" onclick="triggerReset()">Restart [R]</button>
    </div>

    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="score-board">ZEBRANA KREW: <span id="total-points">0</span></div>

<script>
const TILE_SIZE = 64;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const titleElem = document.getElementById('game-title');

const initialMap = [
    "#############",
    "#R..B......S#",
    "#...B..######",
    "#.K.B.......#",
    "#####D#######",
    "#S..........#",
    "#######..S..#",
    "#.......#####",
    "#S..B......E#",
    "#############"
];

let grid, player, bloodTotal, bloodCollected, keys, frame, isGameOver;
let totalScore = 0;
let enemies = [];
let enemyUpdateTick = 0;

function showMessage(text, className, duration = 2000) {
    titleElem.innerText = text;
    titleElem.className = className;
    setTimeout(() => {
        titleElem.innerText = "ROBBLORNE";
        titleElem.className = "";
    }, duration);
}

function triggerReset() {
    isGameOver = false;
    grid = initialMap.map(row => row.split(''));
    bloodCollected = 0; keys = 0; frame = 0;
    bloodTotal = (initialMap.join('').match(/S/g) || []).length;
    // PajƒÖk startuje pod ≈õcianƒÖ. Usuniƒôto startX/range na rzecz fizycznego wykrywania ≈õcian.
    enemies = [{ x: 11, y: 3, dir: -1, icon: "üï∑Ô∏è" }];
    updateUI();
}

function updateUI() {
    document.getElementById('blood-val').innerText = `${bloodCollected} / ${bloodTotal}`;
    document.getElementById('total-points').innerText = totalScore;
}

function drawTile(x, y, type) {
    const px = x * TILE_SIZE; const py = y * TILE_SIZE;
    ctx.fillStyle = "#0c0d11"; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    ctx.strokeStyle = "#1a1a1a"; ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);

    if (type === '#') {
        ctx.fillStyle = "#1a1e26"; ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
        ctx.strokeStyle = "#333"; ctx.strokeRect(px + 8, py + 8, TILE_SIZE - 16, TILE_SIZE - 16);
    } else if (type === 'R') {
        ctx.font = "40px serif"; ctx.fillText("üïµÔ∏è", px + 12, py + 48);
        player = { x, y };
    } else if (type === 'S') {
        const pulse = Math.sin(frame * 0.1) * 3;
        ctx.font = `${32 + pulse}px serif`; ctx.shadowBlur = 15; ctx.shadowColor = "red";
        ctx.fillText("ü©∏", px + 15 - pulse/2, py + 45 + pulse/2);
        ctx.shadowBlur = 0;
    } else if (type === 'B') {
        ctx.fillStyle = "#2a1515"; ctx.fillRect(px + 10, py + 8, TILE_SIZE - 20, TILE_SIZE - 16);
        ctx.strokeStyle = "#444"; ctx.strokeRect(px + 14, py + 12, TILE_SIZE - 28, TILE_SIZE - 24);
    } else if (type === 'K') {
        ctx.font = "30px serif"; ctx.fillText("üóùÔ∏è", px + 15, py + 45);
    } else if (type === 'D') {
        ctx.fillStyle = "#300000"; ctx.fillRect(px+2, py+2, TILE_SIZE-4, TILE_SIZE-4);
        ctx.strokeStyle = "#c5a059"; ctx.strokeRect(px+6, py+6, TILE_SIZE-12, TILE_SIZE-12);
        ctx.font = "30px serif"; ctx.fillText("‚õ©Ô∏è", px + 15, py + 45);
    } else if (type === 'E') {
        if (bloodCollected < bloodTotal) ctx.globalAlpha = 0.2;
        ctx.font = "45px serif"; ctx.shadowBlur = (bloodCollected >= bloodTotal) ? 20 : 0;
        ctx.shadowColor = "#c5a059"; ctx.fillText("‚õ™", px + 10, py + 50);
        ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
    }
}

function updateEnemies() {
    if (isGameOver) return;
    enemyUpdateTick++;
    if (enemyUpdateTick % 20 === 0) {
        enemies.forEach(en => {
            let nextX = en.x + en.dir;
            
            // FIZYCZNE WYKRYWANIE ≈öCIAN: 
            // PajƒÖk odbija siƒô od wszystkiego co nie jest przej≈õciem, krwiƒÖ lub kluczem
            let targetTile = grid[en.y][nextX];
            if (targetTile === '#' || targetTile === 'B' || targetTile === 'D' || targetTile === 'E') {
                en.dir *= -1; // Odbicie
                nextX = en.x + en.dir;
            }
            
            en.x = nextX;
            if (en.x === player.x && en.y === player.y) die();
        });
    }
}

function die() {
    isGameOver = true;
    showMessage("POCH≈ÅONƒò≈ÅA CIƒò CIEMNO≈öƒÜ", "msg-death");
    setTimeout(triggerReset, 1500);
}

function win() {
    isGameOver = true;
    showMessage("KOSZMAR PRZEZWYCIƒò≈ªONY", "msg-win");
    setTimeout(triggerReset, 3000);
}

function update() {
    canvas.width = grid[0].length * TILE_SIZE;
    canvas.height = grid.length * TILE_SIZE;
    updateEnemies();
    grid.forEach((row, y) => { row.forEach((tile, x) => drawTile(x, y, tile)); });
    enemies.forEach(en => {
        ctx.font = "40px serif";
        ctx.fillText(en.icon, en.x * TILE_SIZE + 12, en.y * TILE_SIZE + 48);
    });
    updateUI();
    frame++; requestAnimationFrame(update);
}

window.onkeydown = (e) => {
    if (isGameOver) return;
    if (e.key.toLowerCase() === 'r') { triggerReset(); return; }
    let dx = 0, dy = 0;
    if (e.key === "ArrowUp") dy = -1; if (e.key === "ArrowDown") dy = 1;
    if (e.key === "ArrowLeft") dx = -1; if (e.key === "ArrowRight") dx = 1;
    if (dx === 0 && dy === 0) return;
    
    const nx = player.x + dx; const ny = player.y + dy;
    if (!grid[ny] || !grid[ny][nx]) return;
    if (enemies.some(en => en.x === nx && en.y === ny)) { die(); return; }

    const target = grid[ny][nx];
    if (target === '.' || target === 'S' || target === 'K') {
        if (target === 'S') { bloodCollected++; totalScore++; }
        if (target === 'K') keys++;
        grid[player.y][player.x] = '.'; grid[ny][nx] = 'R';
    } else if (target === 'B') {
        const bx = nx + dx, by = ny + dy;
        if (grid[by] && grid[by][bx] === '.') {
            grid[by][bx] = 'B'; grid[player.y][player.x] = '.'; grid[ny][nx] = 'R';
        }
    } else if (target === 'D' && keys > 0) {
        keys--; grid[player.y][player.x] = '.'; grid[ny][nx] = 'R';
    } else if (target === 'E' && bloodCollected >= bloodTotal) {
        win();
    }
};

triggerReset();
update();
</script>
</body>
</html>